# [如何带着问题去学习正则][1]



---

之前学过一遍正则，但具体运用上经常实践拿（bai）来(du)主义，这就导致了书到用时方恨少，百度知多少。。。（不能偷懒啊，正则是个美妙的东西）

我一直觉得带着问题去学习是最快的。刚好借着这个机会学习一波

实现一个正则验证手机号码
------------

借着问题把学习拆分一下：

 1. 正则写出来要能验证数字。=>需要我们学习字符类去匹配不同的类型（数字，字母等）
 2. 学习完字符类，知道了/[0-9]/能匹配数字，但验证11位手机号码我们是否需要写11遍？这个时候就需要去学习量词减少重复等书写[0-9]。=>
    /[0-9]{11}/
 3. 现在的正则已经能验证11位数字了，如果想书写更加简洁一些，需要学习元字符去简写。=>/d{11}/

然而现在写的正则只要是含有11个连着的数字都能通过验证，需要去限定有其他字符的出现，此时就需要去学习锚点 去限制开头和结尾都是 =>
    /^d{11}$/

在做一些微调，比如我国手机都是1开头的，可以这么写/^1d{10}$/提高匹配精确度。还有一些更加细的规则比如 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188 开头是移动手机号等等，完善到更详细实用吧

附上我自己的学习笔记，以及[我的实现][2]
-----------------

**正则表达式**

 - 概念：
     - 描述字符串规则的表达式
 - 生成方式
    - /pattern/attrs

    - new RegExp(pattern,attrs)
    regexObject.test(str)

 - 测试正则表达式与指定字符串是否匹配

 - 只需要字符串包含正则所描述的规则就返回true，否则返回false

**锚点**

 - 匹配一个位置

    - ^:起始位置
        - /^http:/ 匹配http起始的字符串
        - /^139/ 匹配139起始的字符串
    - $:结尾位置
        - /.jpg$/ 匹配.jpg结尾的字符串，用于判断文件类型
    - b:表示单词边界
        - /bisb/ 匹配is 这个单词
        - /bisb/.test('this') // false
        - /bisb/.test('this is tom') // true

**字符类**

- 匹配一类字符中的一个
    - /[abc]/ 匹配a或b或c
    - /[0-9]/ 匹配任意一个数字，等价于手动输入123456789
    - /[^0-9]/ ^在字符类中的含义和在锚点中含义不同，在字符类中表示‘非’
    - /[a-z]/ 匹配任意一个字母
    - . 点号匹配除了换行意外的任意字符
   
**元字符**

- 具有特殊意义的元字符
    - ^,$,b
    - d :[0-9]字符类的缩写
    - D :[^0-9]非数字，也可以写作[^d]
    - s :空白符
    - S :非空白符
    - w :[A-Za-z0-9]单词字符
    - W :非单词字符
    
**量词**

- 出现的次数

 - {m,n} :m~n次
    - ：{1,}出现1到无穷次，即至少出现一次
    -   ？ : {0,1}出现0或者1次。
    -  : {0,}出现 0到无穷次

    

正则的一些其他东西
---------

**转义符**

-   需要匹配的字符中包含元字符，因为元字符有特殊含义，如果需要匹配的是元字符作为字符串的内容，则需要加上转义符 ``
    - 匹配http开头的字符串 : /^http:/// => /http:///
    - 匹配网址中的. ：/@163.com$/ => /@163.com/
    
**多选分支**

- 或 ：|
    - /thi(c|n)k/ 匹配 thick或 think 也可以用/thi[cn]k/表示
    - /.(jpg|png|gif)$/ 匹配图片文件

**捕获**

- 保存匹配到的字符串，之后再用
    - () :捕获
    - (?:) :不捕获

- 使用
    - $1,$2,...
    - API参数或返回值

1.`str.match(regexp)`

- 获取匹配的字符串

- `str.replace(regexp/substr,replacement)`

- 替换一个子字符串

**捕获练习：**

 获取url的protocol,host,pathname,search,hash等各个部分

    let url ='https://leon-z.me/blog/32?id=2#comment';
    let reg=/(https?:)//([^/]+)(/[^?]*)?(?[^#]*)?(#.*)?/
    let arr=url.match(reg)
    console.log(arr)
替换'this price is 5.'中的价格为'5.00'的表示方法
```javascript
let str='this price is 5';
console.log(str.replace(/(d+)/,'$1.00'))
```

更强大的检索能力：regexpObject.exec(str)

- 更详尽的结果

- 过程等状态


  [1]: http://ife.baidu.com/note/detail/id/43
  [2]: http://leon-z.me/2017-Baidu-IFE/baidu-rice/getting-start-regexp/